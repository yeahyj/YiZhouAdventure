import { _decorator, Component, Enum, GAME_VIEW, Sprite, SpriteFrame } from 'cc';
import { EDITOR } from 'cc/env';
const { ccclass, property, menu, requireComponent } = _decorator;

declare module 'cc' {
    const GAME_VIEW: boolean;
}

enum EventType {
    /**
     * @en Emit when begin playing animation
     * @zh 开始播放时触发。
     */
    PLAY = 'play',
    /**
     * @en Emit when stop playing animation
     * @zh 停止播放时触发。
     */
    STOP = 'stop',
    /**
     * @en Emit when pause animation
     * @zh 暂停播放时触发。
     */
    PAUSE = 'pause',
    /**
     * @en Emit when resume animation
     * @zh 恢复播放时触发。
     */
    RESUME = 'resume',
    /**
     * @en If animation repeat count is larger than 1, emit when animation play to the last frame.
     * @zh 假如动画循环次数大于 1，当动画播放到最后一帧时触发。
     */
    LASTFRAME = 'lastframe',
    /**
     * @en Triggered when finish playing animation.
     * @zh 动画完成播放时触发。
     */
    FINISHED = 'finished'
}

/**播放完成回调 */
interface IComplete { (success?: boolean): void }
/**自动播放生命周期枚举 */
enum Time { none = 0, onLoad = 1, start = 2, onEnable = 3 }
/**自动播放生命周期声明 */
const timeEnum = Enum(Time);

@ccclass('pkg:FrameAnimationClip')
export class FrameAnimationClip {
    @property
    animation: string = 'animation';

    @property
    frameRate: number = 30;

    @property([SpriteFrame])
    spriteFrames: SpriteFrame[] = [];
}

@ccclass('pkg:FrameAnimation')
@requireComponent(Sprite)
@menu('pkg/FrameAnimation')
export class FrameAnimation extends Component {
    static EventType = EventType;

    @property([FrameAnimationClip])
    clips: FrameAnimationClip[] = [];

    @property
    private _timeScale: number = 1;
    @property({ tooltip: '播放速度倍率' })
    get timeScale(): number {
        return this._timeScale;
    }
    set timeScale(value: number) {
        this._timeScale = value;
    }

    @property({ type: timeEnum, tooltip: '自动播放时机 none为不播放' })
    /**自动播放选项 */
    private autoPlay: Time = Time.none;

    @property
    private _loop: boolean = false;
    @property({ visible(this: FrameAnimation) { return this.autoPlay !== Time.none; } })
    private get loop(): boolean {
        if (this._loop === false) return this._loop;
        return this.autoPlay === Time.none ? false : this._loop;
    }
    private set loop(value: boolean) {
        this._loop = value;
    }

    @property
    private _animation: string = 'animation';
    @property({ visible(this: FrameAnimation) { return this.autoPlay !== Time.none; } })
    private get animation(): string {
        return this._animation;
    }
    private set animation(value: string) {
        this._animation = value;
    }

    /**渲染组件 */
    private sprite: Sprite = null;

    private getClip(animation: string) {
        return this.clips.find(clip => clip.animation === animation);
    }

    private display() {
        this.render(this.getClip(this.animation), this.timeScale >= 0 ? 0 : -1);
    }

    private render(clip: FrameAnimationClip, index: number) {
        if (!clip) {
            this.sprite.spriteFrame = null;
            return index;
        }

        index = index >= 0 ? (index % clip.spriteFrames.length) : (index % clip.spriteFrames.length + clip.spriteFrames.length - 1);
        const frame = clip.spriteFrames[index];
        if (!frame) return index;

        // 必须先设置null，不然在编辑器中预览会导致不刷新
        this.sprite.spriteFrame = null;
        this.sprite.spriteFrame = frame;

        return index;
    }

    /**渲染下标 */
    private _renderIndex = 0;
    /**渲染等待时间 */
    private _renderDelayTime = 0;

    /**完成回调 */
    private _completeCallback: IComplete = null;
    /**循环次数 */
    private _loopTimes: number = 0;
    /**已经完成的次数 */
    private _completeTimes: number = 0;
    /**是否正在播放 */
    private _playing: boolean = false;
    /**是否暂停了 */
    private _paused: boolean = false;
    /**是否播放完成自动销毁 */
    private _autoDestroy: boolean = false;

    /**完成一次播放 */
    private onComplete() {
        this._completeTimes++;
        // 循环时每次完成都进行回调
        this._completeCallback && this._completeCallback(true);
        if (this._loopTimes > 0 && this._completeTimes >= this._loopTimes) {
            this.stop();
            // 自动销毁
            if (this._autoDestroy) this.node.destroy();
        }
    }

    protected onLoad() {
        this.sprite = this.node.getComponent(Sprite);
        this.display();

        // 自动播放处理
        if (this.autoPlay === Time.onLoad && (!EDITOR || GAME_VIEW)) {
            this.play(this.animation, this.loop ? -1 : 1);
        }
    }

    protected start() {
        if (this.autoPlay === Time.start && (!EDITOR || GAME_VIEW)) {
            this.play(this.animation, this.loop ? -1 : 1);
        }
    }

    protected onEnable() {
        if (this.autoPlay === Time.onEnable && (!EDITOR || GAME_VIEW)) {
            this.play(this.animation, this.loop ? -1 : 1);
        }
    }

    protected onDestroy() {
    }

    protected update(dt: number) {
        if (EDITOR && !GAME_VIEW) return;
        if (!this._playing || this._paused) return;
        if (this.timeScale === 0) return;

        if (this._renderDelayTime > 0) {
            this._renderDelayTime -= dt;
        }
        if (this._renderDelayTime <= 0) {
            const clip = this.getClip(this.animation);
            if (!clip) {
                this._renderDelayTime = 0;
                return;
            }

            if (this.timeScale > 0) {
                this._renderIndex = this.render(clip, this._renderIndex) + 1;
                this._renderDelayTime += 1 / clip.frameRate / this.timeScale;

                if (this._renderIndex >= clip.spriteFrames.length) {
                    if (!EDITOR || GAME_VIEW) {
                        if (this.loop) this.node.emit(FrameAnimation.EventType.LASTFRAME);
                        this.node.emit(FrameAnimation.EventType.FINISHED);
                        this.onComplete();
                    }
                }
            } else {
                this._renderIndex = this.render(clip, this._renderIndex) - 1;
                this._renderDelayTime += 1 / clip.frameRate / Math.abs(this.timeScale);

                if (this._renderIndex <= -1) {
                    if (!EDITOR || GAME_VIEW) {
                        if (this.loop) this.node.emit(FrameAnimation.EventType.LASTFRAME);
                        this.node.emit(FrameAnimation.EventType.FINISHED);
                        this.onComplete();
                    }
                }
            }

        }
    }

    /**
     * @description: 播放动画
     * @param {string} animation 动画名称
     * @param {number} times 播放次数
     * @param {{onComplete?: IComplete, timeScale?: number, autoDestroy?: boolean}} opts 可选项
     */
    public play(animation: string, times: number = 1, opts?: { onComplete?: IComplete, timeScale?: number, autoDestroy?: boolean }) {
        // 先停止
        this.stop();
        // 无效名称返回
        if (!animation) return;
        // 设置播放速率
        this.timeScale = opts?.timeScale ?? this.timeScale;
        // 设置自动销毁
        this._autoDestroy = opts?.autoDestroy || false;
        // 设置回调
        this._completeCallback = opts?.onComplete || null;
        // 设置循环次数
        this._loopTimes = Math.floor(times);
        // 初始化数据
        this.loop = true;
        this._renderIndex = this.timeScale >= 0 ? 0 : -1;
        this._renderDelayTime = 0;
        this._completeTimes = 0;
        this._paused = false;
        this._playing = true;
        // 设置动画名称
        this.animation = animation;
        this.node.emit(FrameAnimation.EventType.PLAY);
    }

    /**
     * @description: 播放1次动画
     * @param {string} animation 动画名称
     * @param {{onComplete?: IComplete, timeScale?: number, autoDestroy?: boolean }} opts 可选项
     */
    public playOnce(animation: string, opts?: { onComplete?: IComplete, timeScale?: number, autoDestroy?: boolean }) {
        this.play(animation, 1, opts);
    }

    /**
     * @description: 循环播放动画
     * @param {string} animation 动画名称
     * @param {{onComplete?: IComplete, timeScale?: number}} opts 可选项
     */
    public playLoop(animation: string, opts?: { onComplete?: IComplete, timeScale?: number }) {
        this.play(animation, -1, opts);
    }

    /**
     * @description: 停止播放
     */
    public stop() {
        if (this._playing) {
            this._playing = false;
            this._paused = false;
            this.display();
            // 完成一次播放的中途被停止了执行失败回调
            if ((this._loopTimes < 0 || this._loopTimes > this._completeTimes) && this._completeCallback) {
                this._completeCallback(false);
                this._completeCallback = null;
            }
            this.node.emit(FrameAnimation.EventType.STOP);
            return true;
        }
        return false;
    }

    /**
     * @description: 暂停
     * @returns {boolean}
     */
    public pause(): boolean {
        if (this._playing) {
            this._paused = true;
            this.node.emit(FrameAnimation.EventType.PAUSE);
            return true;
        }
        return false;
    }

    /**
     * @description: 恢复暂停
     * @returns {boolean}
     */
    public resume(): boolean {
        if (this._playing) {
            this._paused = false;
            this.node.emit(FrameAnimation.EventType.RESUME);
            return true;
        }
        return false;
    }
}

