import { Enum, _decorator, sp } from 'cc';
import { EDITOR } from 'cc/env';
const { ccclass, property, menu, executeInEditMode } = _decorator;

/**播放完成回调 */
interface IComplete { (success?: boolean): void }
/**自动播放生命周期枚举 */
enum Time { none = 0, onLoad = 1, start = 2, onEnable = 3 }
/**自动播放生命周期声明 */
const timeEnum = Enum(Time);

@ccclass('pkg:Skeleton')
@menu('pkg/Skeleton')
@executeInEditMode
//@ts-ignore
export class Skeleton extends sp.Skeleton {
    /**自动播放选项 */
    @property({ type: timeEnum, tooltip: '自动播放时机 none为不播放 animation和loop遵循选项' })
    private autoPlay: Time = Time.none;
    /**隐藏loop选项并私有化 */
    @property({ visible(this: Skeleton) { return this.autoPlay !== Time.none; }, override: true })
    private loop: boolean = false;
    /**预乘开关改为默认为关闭 */
    @property({ serializable: true, override: true })
    protected _premultipliedAlpha = false;

    /**私有化paused */
    private paused: boolean = false;
    /**完成回调 */
    private _completeCallback: IComplete = null;
    /**循环次数 */
    private _times: number = 0;
    /**已经完成的次数 */
    private _completeTimes: number = 0;
    /**是否正在播放 */
    private _playing: boolean = false;
    /**是否播放完成自动销毁 */
    private _autoDestroy: boolean = false;

    private gotoCache = {
        time: 0,
        animation: '',
    };

    protected onLoad() {
        super.onLoad();
        // 设置默认参数
        this.paused = true;
        this.loop = this.autoPlay !== Time.none ? this.loop : false;
        this.timeScale = this.autoPlay !== Time.none ? this.timeScale : 1;
        // 完成一次播放
        this.setCompleteListener(() => {
            this._completeTimes++;
            // 循环时每次完成都进行回调
            this._completeCallback && this._completeCallback(true);
            if (this._times > 0 && this._completeTimes >= this._times) {
                this.stop();
                // 自动销毁
                if (this._autoDestroy) this.node.destroy();
            }
        });
        // 自动播放处理
        if (this.autoPlay === Time.onLoad && !EDITOR) this.play(this.animation, this.loop ? -1 : 1, { timeScale: this.timeScale });
    }

    protected start() {
        if (this.autoPlay === Time.start && !EDITOR) this.play(this.animation, this.loop ? -1 : 1, { timeScale: this.timeScale });
    }

    protected onEnable() {
        super.onEnable();
        if (this.autoPlay === Time.onEnable && !EDITOR) this.play(this.animation, this.loop ? -1 : 1, { timeScale: this.timeScale });
    }

    /**
     * @description: 播放Spine
     * @param {string} animation 动画名称
     * @param {number} times 播放次数
     * @param {{onComplete?: IComplete, timeScale?: number, autoDestroy?: boolean}} opts 可选项
     */
    public play(animation: string, times: number = 1, opts?: { onComplete?: IComplete, timeScale?: number, autoDestroy?: boolean }) {
        this.gotoCache.time = 0;
        this.gotoCache.animation = '';
        // 先停止
        this.stop();
        // 无效名称返回
        if (animation === '<None>') return;
        // 设置播放速率
        this.timeScale = opts?.timeScale ?? 1;
        // 设置自动销毁
        this._autoDestroy = opts?.autoDestroy || false;
        // 设置回调
        this._completeCallback = opts?.onComplete || null;
        // 设置循环次数
        this._times = Math.floor(times);
        // 初始化数据
        this._completeTimes = 0;
        // 设置loop paused，必须在设置animation前
        this.loop = true;
        this.paused = false;
        this._playing = true;
        // 设置动画名称
        if (typeof animation === 'string') this.animation = animation;
    }

    /**
     * @description: 播放1次spine
     * @param {string} animation 动画名称
     * @param {{onComplete?: IComplete, timeScale?: number, autoDestroy?: boolean }} opts 可选项
     */
    public playOnce(animation: string, opts?: { onComplete?: IComplete, timeScale?: number, autoDestroy?: boolean }) {
        this.play(animation, 1, opts);
    }

    /**
     * @description: 循环播放spine
     * @param {string} animation 动画名称
     * @param {{onComplete?: IComplete, timeScale?: number}} opts 可选项
     */
    public playLoop(animation: string, opts?: { onComplete?: IComplete, timeScale?: number }) {
        this.play(animation, -1, opts);
    }

    /**
     * 根据时间跳转到那一刻
     * @param animation 动画名称
     * @param time 时间
     */
    public goto(animation: string, time: number) {
        time = Math.max(0, time);
        if (animation === '<None>' || !animation) {
            this.gotoCache.time = 0;
            this.gotoCache.animation = '';
            return this.stop();
        }
        if (this.gotoCache.animation !== animation) {
            this.gotoCache.time = 0;
            this.gotoCache.animation = animation;
            this.stop();
            this.animation = animation;
            this.timeScale = 1;
            this.loop = false;
        }
        this.paused = false;

        const anim = this.findAnimation(animation);
        if (anim) {
            time = Math.min(time, anim.duration);
            this.updateAnimation(time - this.gotoCache.time);
            this.gotoCache.time = time;
        }
        this.paused = true;
    }

    /**
     * @description: 停止播放
     */
    public stop() {
        if (this._playing) {
            this._playing = false;
            this.paused = true;
            this.setToSetupPose();
            // 完成一次播放的中途被停止了执行失败回调
            if ((this._times < 0 || this._times > this._completeTimes) && this._completeCallback) {
                this._completeCallback(false);
                this._completeCallback = null;
            }
            return true;
        }
        return false;
    }

    /**
     * @description: 暂停
     * @returns {boolean}
     */
    public pause(): boolean {
        if (this._playing) {
            this.paused = true;
            return true;
        }
        return false;
    }

    /**
     * @description: 恢复暂停
     * @returns {boolean}
     */
    public resume(): boolean {
        if (this._playing) {
            this.paused = false;
            return true;
        }
        return false;
    }

    /**
     * 设置皮肤
     */
    public setSkin(name?: string) {
        if (!name) name = this.defaultSkin;
        if (name) super.setSkin(name);
    }
}
